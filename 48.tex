\section{
    Коды, исправляющие ошибки...
}

\textbf{Коды, исправляющие ошибки. Минимальное расстояние. Линейные коды. Вычисление минимального расстояния для линейных кодов.}

Шпаргалка: да вроде и не нужна? %(TODO or not TODO?)



Сообщения -- это строки длины $n$ из алфавита $\mc A$. Хотим их кодировать -- сопоставить каждой строке из $\mc A^n$ строку из $\mc B^m$ так, чтобы даже если сообщение немного поломается при передаче можно было понять, что передавали.

Считаем, что единственные проблемы, случающиеся со строками при передаче это изменение в нескольких позициях. 

\dfn[Расстояние Хемминга] Пусть даны два слова $x,y \in \mc A^n$. Тогда расстоянием Хемминга между ними называется число позиций, в которых эти слова различаются
$$\rho_H(x,y)=|\{1\leq i \leq n \, |\, x_i \neq y_i \}|.$$
\edfn

Хотим, чтобы наши коды были устойчивы к таким изменениям.

\dfn Кодом называется подмножество $C \subseteq \mc B^m$ равномощное $\mc A^n$. Его элементы называются кодовыми словами.
\edfn

\dfn Кодовым расстоянием называется величина
$$d_{min}= \min_{\substack{x,y\in C \\ x \neq y}} \rho_H(x,y).$$
\edfn

\dfn Код $C$ обнаруживает $d$ ошибок, если ни в каком кодовом слове нельзя сделав $\le d$ ошибок получить другое кодовое слово. Эквивалентно тому, что $\forall x, y \in C\ \rho_H(x, y) > d$, эквивалентно $d_{min} > d$
\edfn

\dfn Будем исправлять ошибки максимально просто -- приняв какую-то строку возьмем ближайшее по расстоянию Хэмминга кодовое слово. Код $C$ исправляет $d$ ошибок, если при исправлении любого кодового слова, дошедшего с $\le d$ ошибками, получается исходное слово. То есть на расстоянии $d$ от кодового слова ближайшим будет оно само, то есть расстояние до остальных будет больше, то есть расстояние от кодового слова до остальных хотя бы $2d+1$ то есть $d_{min} \ge 2d+1$.
\edfn

Обычно алфавиты исходных строк и кодов выбирают одинаковыми. Будем обозначать размер алфавита за $q$. Если $q=2$ то коды называются бинарными.
 
Особенно удобно и алгебраично работать с алфавитами размера $q=p^n$, считать что на нем задано конечно поле, и искать линейные отображения $K \colon \mb F_q^k \to \mb F_q^n$ 

\dfn Линейным $n,k,q$-кодом называется $k$-мерное подпространство в $\mb F_q^n$. Отношение $\frac{k}{n}$ называется скоростью кода.
\edfn

Если отображение $K$ линейно, то оно задаётся матрицей размера $n\times k$ и ранга $k$ (инъекция), которая обозначается $G$ и называется порождающей матрицей. Одному коду могут соответствовать разные $K$.

\dfn Кодирование называется систематическим, если $G$ имеет вид $(E_k|G')$. Такая матрица гарантирует, что первые $k$ знаков исходного сообщения записаны в первые $k$ знаков исходного слова, следовательно проще декодировать если нет ошибок.
\edfn

\dfn
$C$ -- подпространство, значит есть $H$ -- матрица $n-k\times n$ ранга $n-k$, что $\Ker H = C$. Такая матрица называется проверочной матрицей кода $C$. $\Ker H = \Im G \Rightarrow HG = 0$
\edfn

Часто проверочной матрицей называют матрицу $H^{\top}$. Это удобно, если заметить, что такая матрица является порождающей  $(n,n-k,q)$ кода (т.к. ее ранг $n-k$). Почему удобно -- загадка (TODO)

\lm Пусть $C$ -- линейный код. Тогда кодовое расстояние $d$ равно 
$$d=\min_{\substack{x \in C \\ x\neq 0} } \rho_H(0,x) = $$ мин кол-во линейно зависимых столбцов $H$.
\proof 
$$\rho_H(x, y) = \rho_H(x-y, 0) \Rightarrow \min \rho_H(x, y) = \min \rho_H(x, 0)$$
$x \in C \Leftrightarrow Hx = 0$. Минимальное кол-во отличных от нуля значений в $x$ очевидно равно мин кол-во линейно зависимых столбцов $H$.
\endproof
\elm

Как декодировать полученное сообщение? Пусть $v$ -- то, что пришло, $Hv=s$. Надо найти $w \in C = \im G$, что $v-w$ минимально отличается от $0$ (по $\rho_H$). Можно перебрать все $u \in \mb F_q^k$ и выбрать ближайший к $0$ из $v - Gu$. Но это долговато. Для лучшего результата понадобятся циклический коды, но это уже совершенно другой вопрос.